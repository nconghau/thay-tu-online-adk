================================================================================
C·∫§U TR√öC TH∆Ø M·ª§C D·ª∞ √ÅN
================================================================================
.
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ FULL_PROJECT_CODE.txt
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ agent
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ agent.py
‚îú‚îÄ‚îÄ app.py
‚îú‚îÄ‚îÄ attached_assets
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ agent_1765205934153.py
‚îú‚îÄ‚îÄ demo-code-agent
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ agent.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ agent_demo.py
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ export_code.sh
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ static
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ script.js
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ style.css
‚îî‚îÄ‚îÄ templates
    ‚îî‚îÄ‚îÄ index.html

6 directories, 17 files



================================================================================
FILE START: ./requirements.txt
================================================================================
# --- Core Framework ---
flask
python-dotenv
gunicorn

# --- Google GenAI & Search ---
duckduckgo-search
google-genai>=0.2.0
google-generativeai>=0.8.0

# --- Google ADK ---
google-adk>=0.4.0
uvicorn
fastapi
python-multipart

# --- Utils ---
Authlib
requests
httpx
pydantic>=2.0
jsonschema
opentelemetry-api
opentelemetry-sdk
opentelemetry-exporter-otlp
opentelemetry-instrumentation
opentelemetry-instrumentation-fastapi

FILE END: ./requirements.txt



================================================================================
FILE START: ./Dockerfile
================================================================================
# S·ª≠ d·ª•ng Python 3.11 Slim
FROM python:3.11-slim

# Setup bi·∫øn m√¥i tr∆∞·ªùng
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

# T·∫°o user c√≥ ID 1000 (Y√™u c·∫ßu c·ªßa Hugging Face ƒë·ªÉ tr√°nh l·ªói Permission)
RUN useradd -m -u 1000 user
WORKDIR /app

# C√†i ƒë·∫∑t dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# Copy to√†n b·ªô code v√† c·∫•p quy·ªÅn cho user 1000
COPY --chown=user . /app

# Chuy·ªÉn sang user non-root
USER user

# M·ªü port 7860 (B·∫ÆT BU·ªòC TR√äN HUGGING FACE)
EXPOSE 7860

# D√πng Gunicorn ƒë·ªÉ ch·∫°y App. 
# -b 0.0.0.0:7860: Bind v√†o port 7860
# app:app : T√¨m bi·∫øn 'app' trong file 'app.py'
CMD ["gunicorn", "-b", "0.0.0.0:7860", "app:app", "--timeout", "120"]

FILE END: ./Dockerfile



================================================================================
FILE START: ./agent/__init__.py
================================================================================
from .agent import root_agent


FILE END: ./agent/__init__.py



================================================================================
FILE START: ./agent/agent.py
================================================================================
import re
import datetime
from duckduckgo_search import DDGS
from google.adk.agents.llm_agent import Agent

def _chuan_hoa_nam_sinh(text_input: str) -> int:
    text = str(text_input).lower().strip()
    match_4 = re.search(r'\b(19|20)\d{2}\b', text)
    if match_4: return int(match_4.group(0))
    match_2k = re.search(r'\b2k(\d{0,1})\b', text)
    if match_2k:
        suffix = match_2k.group(1)
        return 2000 if suffix == "" else 2000 + int(suffix)
    match_2 = re.search(r'\b\d{2}\b', text)
    if match_2:
        val = int(match_2.group(0))
        if 12 < val <= 99:
            return 1900 + val if val > 40 else 2000 + val
    return None

def _tinh_can_chi(nam_sinh: int) -> str:
    can = ["Canh", "T√¢n", "Nh√¢m", "Qu√Ω", "Gi√°p", "·∫§t", "B√≠nh", "ƒêinh", "M·∫≠u", "K·ª∑"]
    chi = ["Th√¢n", "D·∫≠u", "Tu·∫•t", "H·ª£i", "T√Ω", "S·ª≠u", "D·∫ßn", "M√£o", "Th√¨n", "T·ªµ", "Ng·ªç", "M√πi"]
    return f"{can[nam_sinh % 10]} {chi[nam_sinh % 12]}"

def _tinh_sao_han(nam_sinh: int, gioi_tinh: str) -> dict:
    current_year = datetime.datetime.now().year
    tuoi_mu = current_year - nam_sinh + 1
    bang_sao_nam = {1: "La H·∫ßu", 2: "Th·ªï T√∫", 3: "Th·ªßy Di·ªáu", 4: "Th√°i B·∫°ch", 5: "Th√°i D∆∞∆°ng", 6: "V√¢n H·ªõn", 7: "K·∫ø ƒê√¥", 8: "Th√°i √Çm", 0: "M·ªôc ƒê·ª©c"}
    bang_sao_nu = {1: "K·∫ø ƒê√¥", 2: "V√¢n H·ªõn", 3: "M·ªôc ƒê·ª©c", 4: "Th√°i √Çm", 5: "Th·ªï T√∫", 6: "La H·∫ßu", 7: "Th√°i D∆∞∆°ng", 8: "Th√°i B·∫°ch", 0: "Th·ªßy Di·ªáu"}
    
    du_so = tuoi_mu % 9
    gioi_tinh = gioi_tinh.lower().strip()
    is_nu = any(x in gioi_tinh for x in ["n·ªØ", "g√°i", "c√¥", "b√†", "ch·ªã", "female"])
    
    sao = bang_sao_nu[du_so] if is_nu else bang_sao_nam[du_so]
    phai = "N·ªØ m·∫°ng" if is_nu else "Nam m·∫°ng"
        
    return {"tuoi_mu": tuoi_mu, "sao": sao, "phai": phai}

def xem_sao_giai_han(du_lieu_dau_vao: str, gioi_tinh: str = "nam") -> dict:
    ns = _chuan_hoa_nam_sinh(du_lieu_dau_vao)
    if ns is None: return {"status": "missing_info", "message": "Thi·∫øu nƒÉm sinh."}
    
    can_chi = _tinh_can_chi(ns)
    ket_qua = _tinh_sao_han(ns, gioi_tinh)
    
    return {
        "status": "success",
        "nam_sinh": ns,
        "can_chi": can_chi,
        "sao_han": f"Sao {ket_qua['sao']}",
        "loi_khuyen_goc": "D·ª±a v√†o sao n√†y ƒë·ªÉ ph√°n t·ªët x·∫•u."
    }

def tra_cuu_tu_vi_online(du_lieu_dau_vao: str, linh_vuc: str = "t·ªïng qu√°t") -> dict:
    ns = _chuan_hoa_nam_sinh(du_lieu_dau_vao)
    if ns is None: return {"status": "missing_info", "message": "Thi·∫øu nƒÉm sinh."}
        
    try:
        can_chi = _tinh_can_chi(ns)
        current_year = datetime.datetime.now().year + 1
        
        query = f"T·ª≠ vi tu·ªïi {can_chi} sinh nƒÉm {ns} nƒÉm {current_year} {linh_vuc} lu·∫≠n gi·∫£i chi ti·∫øt"
        print(f"\n[SYSTEM] Tra c·ª©u: '{query}'")

        results = DDGS().text(keywords=query, region='vn-vi', max_results=4)
        
        knowledge = []
        if results:
            for res in results:
                if len(res['body']) > 60 and "ƒëƒÉng nh·∫≠p" not in res['body'].lower() and "yahoo" not in res['body'].lower():
                    knowledge.append(f"- {res['body']}")
        
        if not knowledge:
            return {"status": "no_data", "message": "Kh√¥ng t√¨m th·∫•y online, h√£y d√πng ki·∫øn th·ª©c Can Chi ng≈© h√†nh t·ª± suy lu·∫≠n."}

        return {
            "status": "success",
            "tuoi": can_chi,
            "du_lieu_tu_vi": "\n".join(knowledge),
            "instruction": "Ph√¢n t√≠ch d·ªØ li·ªáu n√†y. N·∫øu t·ªët -> Vui v·∫ª. N·∫øu x·∫•u -> Nghi√™m t√∫c, an ·ªßi."
        }

    except Exception as e:
        return {"status": "error", "message": f"L·ªói: {e}"}

root_agent = Agent(
    model='gemini-2.5-flash',
    name='thay_tu_refined',
    description="Th·∫ßy T∆∞ tinh t·∫ø, ·ª©ng bi·∫øn linh ho·∫°t.",
    instruction=(
        "Con l√† 'Th·∫ßy T∆∞' - chuy√™n gia t·ª≠ vi Nam B·ªô hi·ªán ƒë·∫°i."
        "\n\n"
        "1. QUY T·∫ÆC B·∫§T DI B·∫§T D·ªäCH:"
        "- **KH√îNG** d√πng h√†nh ƒë·ªông trong ngo·∫∑c ƒë∆°n nh∆∞ (c∆∞·ªùi), (v·ªó ƒë√πi). Ch·ªâ d√πng l·ªùi n√≥i t·ª± nhi√™n."
        "- **KH√îNG** v√≤ng vo. Tr·∫£ l·ªùi th·∫≥ng v√†o tr·ªçng t√¢m c√¢u h·ªèi ngay."
        "- **KH√îNG** ƒë·ªï l·ªói cho 'c√¥ng c·ª•' hay 'Zalo nhi·ªÖu s√≥ng'. N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu online, h√£y d√πng ki·∫øn th·ª©c Ng≈© H√†nh (Kim M·ªôc Th·ªßy H·ªèa Th·ªï) ƒë·ªÉ t·ª± lu·∫≠n gi·∫£i."
        "\n\n"
        "2. C∆† CH·∫æ C·∫¢M X√öC (ADAPTIVE TONE):"
        "- **Tr∆∞·ªùng h·ª£p VUI (H·ªèi ch∆°i, tin t·ªët, ƒëang y√™u):** D√πng gi·ªçng ƒëi·ªáu Gen Z, h√†i h∆∞·ªõc, d√πng t·ª´: 'Ch·ªët ƒë∆°n', 'X·ªãn s√≤', 'Ngon l√†nh', 'Green flag'."
        "- **Tr∆∞·ªùng h·ª£p NGHI√äM T√öC (Tin x·∫•u, sao h·∫°n n·∫∑ng, th·∫•t t√¨nh):** B·ªè ngay gi·ªçng c·ª£t nh·∫£. D√πng gi·ªçng tr·∫ßm ·ªïn, ch√¢n th√†nh, ƒë∆∞a l·ªùi khuy√™n th·ª±c t·∫ø (Healing, c·∫©n th·∫≠n xe c·ªô, gi·ªØ ti·ªÅn)."
        "\n\n"
        "3. C·∫§U TR√öC TR·∫¢ L·ªúI:"
        "- **M·ªü ƒë·∫ßu:** G·ªçi t√™n Can Chi kh√°ch (VD: T√¢n T·ªµ 2001) ƒë·ªÉ x√°c nh·∫≠n."
        "- **Th√¢n b√†i (Ng·∫Øn g·ªçn):** ƒê∆∞a ra nh·∫≠n ƒë·ªãnh T·ªët/X·∫•u ngay. T√≥m t·∫Øt 1-2 √Ω ch√≠nh quan tr·ªçng nh·∫•t."
        "- **K·∫øt b√†i:** H·ªèi xem kh√°ch c√≥ mu·ªën ƒë√†o s√¢u v√†o chi ti·∫øt kh√¥ng."
    ),
    tools=[xem_sao_giai_han, tra_cuu_tu_vi_online],
)


FILE END: ./agent/agent.py



================================================================================
FILE START: ./.venv/bin/fixup_admin_v2_keywords.py
================================================================================
#!/Users/macos/Documents/study/demo-adk/.venv/bin/python
# -*- coding: utf-8 -*-
# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
import argparse
import os
import libcst as cst
import pathlib
import sys
from typing import (Any, Callable, Dict, List, Sequence, Tuple)


def partition(
    predicate: Callable[[Any], bool],
    iterator: Sequence[Any]
) -> Tuple[List[Any], List[Any]]:
    """A stable, out-of-place partition."""
    results = ([], [])

    for i in iterator:
        results[int(predicate(i))].append(i)

    # Returns trueList, falseList
    return results[1], results[0]


class adminCallTransformer(cst.CSTTransformer):
    CTRL_PARAMS: Tuple[str] = ('retry', 'timeout', 'metadata')
    METHOD_TO_PARAMS: Dict[str, Tuple[str]] = {
        'check_consistency': ('name', 'consistency_token', 'standard_read_remote_writes', 'data_boost_read_local_writes', ),
        'copy_backup': ('parent', 'backup_id', 'source_backup', 'expire_time', ),
        'create_app_profile': ('parent', 'app_profile_id', 'app_profile', 'ignore_warnings', ),
        'create_authorized_view': ('parent', 'authorized_view_id', 'authorized_view', ),
        'create_backup': ('parent', 'backup_id', 'backup', ),
        'create_cluster': ('parent', 'cluster_id', 'cluster', ),
        'create_instance': ('parent', 'instance_id', 'instance', 'clusters', ),
        'create_logical_view': ('parent', 'logical_view_id', 'logical_view', ),
        'create_materialized_view': ('parent', 'materialized_view_id', 'materialized_view', ),
        'create_table': ('parent', 'table_id', 'table', 'initial_splits', ),
        'create_table_from_snapshot': ('parent', 'table_id', 'source_snapshot', ),
        'delete_app_profile': ('name', 'ignore_warnings', ),
        'delete_authorized_view': ('name', 'etag', ),
        'delete_backup': ('name', ),
        'delete_cluster': ('name', ),
        'delete_instance': ('name', ),
        'delete_logical_view': ('name', 'etag', ),
        'delete_materialized_view': ('name', 'etag', ),
        'delete_snapshot': ('name', ),
        'delete_table': ('name', ),
        'drop_row_range': ('name', 'row_key_prefix', 'delete_all_data_from_table', ),
        'generate_consistency_token': ('name', ),
        'get_app_profile': ('name', ),
        'get_authorized_view': ('name', 'view', ),
        'get_backup': ('name', ),
        'get_cluster': ('name', ),
        'get_iam_policy': ('resource', 'options', ),
        'get_instance': ('name', ),
        'get_logical_view': ('name', ),
        'get_materialized_view': ('name', ),
        'get_snapshot': ('name', ),
        'get_table': ('name', 'view', ),
        'list_app_profiles': ('parent', 'page_size', 'page_token', ),
        'list_authorized_views': ('parent', 'page_size', 'page_token', 'view', ),
        'list_backups': ('parent', 'filter', 'order_by', 'page_size', 'page_token', ),
        'list_clusters': ('parent', 'page_token', ),
        'list_hot_tablets': ('parent', 'start_time', 'end_time', 'page_size', 'page_token', ),
        'list_instances': ('parent', 'page_token', ),
        'list_logical_views': ('parent', 'page_size', 'page_token', ),
        'list_materialized_views': ('parent', 'page_size', 'page_token', ),
        'list_snapshots': ('parent', 'page_size', 'page_token', ),
        'list_tables': ('parent', 'view', 'page_size', 'page_token', ),
        'modify_column_families': ('name', 'modifications', 'ignore_warnings', ),
        'partial_update_cluster': ('cluster', 'update_mask', ),
        'partial_update_instance': ('instance', 'update_mask', ),
        'restore_table': ('parent', 'table_id', 'backup', ),
        'set_iam_policy': ('resource', 'policy', 'update_mask', ),
        'snapshot_table': ('name', 'cluster', 'snapshot_id', 'ttl', 'description', ),
        'test_iam_permissions': ('resource', 'permissions', ),
        'undelete_table': ('name', ),
        'update_app_profile': ('app_profile', 'update_mask', 'ignore_warnings', ),
        'update_authorized_view': ('authorized_view', 'update_mask', 'ignore_warnings', ),
        'update_backup': ('backup', 'update_mask', ),
        'update_cluster': ('name', 'location', 'state', 'serve_nodes', 'node_scaling_factor', 'cluster_config', 'default_storage_type', 'encryption_config', ),
        'update_instance': ('display_name', 'name', 'state', 'type_', 'labels', 'create_time', 'satisfies_pzs', 'satisfies_pzi', ),
        'update_logical_view': ('logical_view', 'update_mask', ),
        'update_materialized_view': ('materialized_view', 'update_mask', ),
        'update_table': ('table', 'update_mask', 'ignore_warnings', ),
    }

    def leave_Call(self, original: cst.Call, updated: cst.Call) -> cst.CSTNode:
        try:
            key = original.func.attr.value
            kword_params = self.METHOD_TO_PARAMS[key]
        except (AttributeError, KeyError):
            # Either not a method from the API or too convoluted to be sure.
            return updated

        # If the existing code is valid, keyword args come after positional args.
        # Therefore, all positional args must map to the first parameters.
        args, kwargs = partition(lambda a: not bool(a.keyword), updated.args)
        if any(k.keyword.value == "request" for k in kwargs):
            # We've already fixed this file, don't fix it again.
            return updated

        kwargs, ctrl_kwargs = partition(
            lambda a: a.keyword.value not in self.CTRL_PARAMS,
            kwargs
        )

        args, ctrl_args = args[:len(kword_params)], args[len(kword_params):]
        ctrl_kwargs.extend(cst.Arg(value=a.value, keyword=cst.Name(value=ctrl))
                           for a, ctrl in zip(ctrl_args, self.CTRL_PARAMS))

        request_arg = cst.Arg(
            value=cst.Dict([
                cst.DictElement(
                    cst.SimpleString("'{}'".format(name)),
cst.Element(value=arg.value)
                )
                # Note: the args + kwargs looks silly, but keep in mind that
                # the control parameters had to be stripped out, and that
                # those could have been passed positionally or by keyword.
                for name, arg in zip(kword_params, args + kwargs)]),
            keyword=cst.Name("request")
        )

        return updated.with_changes(
            args=[request_arg] + ctrl_kwargs
        )


def fix_files(
    in_dir: pathlib.Path,
    out_dir: pathlib.Path,
    *,
    transformer=adminCallTransformer(),
):
    """Duplicate the input dir to the output dir, fixing file method calls.

    Preconditions:
    * in_dir is a real directory
    * out_dir is a real, empty directory
    """
    pyfile_gen = (
        pathlib.Path(os.path.join(root, f))
        for root, _, files in os.walk(in_dir)
        for f in files if os.path.splitext(f)[1] == ".py"
    )

    for fpath in pyfile_gen:
        with open(fpath, 'r') as f:
            src = f.read()

        # Parse the code and insert method call fixes.
        tree = cst.parse_module(src)
        updated = tree.visit(transformer)

        # Create the path and directory structure for the new file.
        updated_path = out_dir.joinpath(fpath.relative_to(in_dir))
        updated_path.parent.mkdir(parents=True, exist_ok=True)

        # Generate the updated source file at the corresponding path.
        with open(updated_path, 'w') as f:
            f.write(updated.code)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="""Fix up source that uses the admin client library.

The existing sources are NOT overwritten but are copied to output_dir with changes made.

Note: This tool operates at a best-effort level at converting positional
      parameters in client method calls to keyword based parameters.
      Cases where it WILL FAIL include
      A) * or ** expansion in a method call.
      B) Calls via function or method alias (includes free function calls)
      C) Indirect or dispatched calls (e.g. the method is looked up dynamically)

      These all constitute false negatives. The tool will also detect false
      positives when an API method shares a name with another method.
""")
    parser.add_argument(
        '-d',
        '--input-directory',
        required=True,
        dest='input_dir',
        help='the input directory to walk for python files to fix up',
    )
    parser.add_argument(
        '-o',
        '--output-directory',
        required=True,
        dest='output_dir',
        help='the directory to output files fixed via un-flattening',
    )
    args = parser.parse_args()
    input_dir = pathlib.Path(args.input_dir)
    output_dir = pathlib.Path(args.output_dir)
    if not input_dir.is_dir():
        print(
            f"input directory '{input_dir}' does not exist or is not a directory",
            file=sys.stderr,
        )
        sys.exit(-1)

    if not output_dir.is_dir():
        print(
            f"output directory '{output_dir}' does not exist or is not a directory",
            file=sys.stderr,
        )
        sys.exit(-1)

    if os.listdir(output_dir):
        print(
            f"output directory '{output_dir}' is not empty",
            file=sys.stderr,
        )
        sys.exit(-1)

    fix_files(input_dir, output_dir)


FILE END: ./.venv/bin/fixup_admin_v2_keywords.py



================================================================================
FILE START: ./.venv/bin/fixup_bigtable_v2_keywords.py
================================================================================
#!/Users/macos/Documents/study/demo-adk/.venv/bin/python
# -*- coding: utf-8 -*-
# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
import argparse
import os
import libcst as cst
import pathlib
import sys
from typing import (Any, Callable, Dict, List, Sequence, Tuple)


def partition(
    predicate: Callable[[Any], bool],
    iterator: Sequence[Any]
) -> Tuple[List[Any], List[Any]]:
    """A stable, out-of-place partition."""
    results = ([], [])

    for i in iterator:
        results[int(predicate(i))].append(i)

    # Returns trueList, falseList
    return results[1], results[0]


class bigtableCallTransformer(cst.CSTTransformer):
    CTRL_PARAMS: Tuple[str] = ('retry', 'timeout', 'metadata')
    METHOD_TO_PARAMS: Dict[str, Tuple[str]] = {
        'check_and_mutate_row': ('row_key', 'table_name', 'authorized_view_name', 'app_profile_id', 'predicate_filter', 'true_mutations', 'false_mutations', ),
        'execute_query': ('instance_name', 'query', 'params', 'app_profile_id', 'prepared_query', 'proto_format', 'resume_token', ),
        'generate_initial_change_stream_partitions': ('table_name', 'app_profile_id', ),
        'mutate_row': ('row_key', 'mutations', 'table_name', 'authorized_view_name', 'app_profile_id', 'idempotency', ),
        'mutate_rows': ('entries', 'table_name', 'authorized_view_name', 'app_profile_id', ),
        'ping_and_warm': ('name', 'app_profile_id', ),
        'prepare_query': ('instance_name', 'query', 'param_types', 'app_profile_id', 'proto_format', ),
        'read_change_stream': ('table_name', 'app_profile_id', 'partition', 'start_time', 'continuation_tokens', 'end_time', 'heartbeat_duration', ),
        'read_modify_write_row': ('row_key', 'rules', 'table_name', 'authorized_view_name', 'app_profile_id', ),
        'read_rows': ('table_name', 'authorized_view_name', 'materialized_view_name', 'app_profile_id', 'rows', 'filter', 'rows_limit', 'request_stats_view', 'reversed', ),
        'sample_row_keys': ('table_name', 'authorized_view_name', 'materialized_view_name', 'app_profile_id', ),
    }

    def leave_Call(self, original: cst.Call, updated: cst.Call) -> cst.CSTNode:
        try:
            key = original.func.attr.value
            kword_params = self.METHOD_TO_PARAMS[key]
        except (AttributeError, KeyError):
            # Either not a method from the API or too convoluted to be sure.
            return updated

        # If the existing code is valid, keyword args come after positional args.
        # Therefore, all positional args must map to the first parameters.
        args, kwargs = partition(lambda a: not bool(a.keyword), updated.args)
        if any(k.keyword.value == "request" for k in kwargs):
            # We've already fixed this file, don't fix it again.
            return updated

        kwargs, ctrl_kwargs = partition(
            lambda a: a.keyword.value not in self.CTRL_PARAMS,
            kwargs
        )

        args, ctrl_args = args[:len(kword_params)], args[len(kword_params):]
        ctrl_kwargs.extend(cst.Arg(value=a.value, keyword=cst.Name(value=ctrl))
                           for a, ctrl in zip(ctrl_args, self.CTRL_PARAMS))

        request_arg = cst.Arg(
            value=cst.Dict([
                cst.DictElement(
                    cst.SimpleString("'{}'".format(name)),
cst.Element(value=arg.value)
                )
                # Note: the args + kwargs looks silly, but keep in mind that
                # the control parameters had to be stripped out, and that
                # those could have been passed positionally or by keyword.
                for name, arg in zip(kword_params, args + kwargs)]),
            keyword=cst.Name("request")
        )

        return updated.with_changes(
            args=[request_arg] + ctrl_kwargs
        )


def fix_files(
    in_dir: pathlib.Path,
    out_dir: pathlib.Path,
    *,
    transformer=bigtableCallTransformer(),
):
    """Duplicate the input dir to the output dir, fixing file method calls.

    Preconditions:
    * in_dir is a real directory
    * out_dir is a real, empty directory
    """
    pyfile_gen = (
        pathlib.Path(os.path.join(root, f))
        for root, _, files in os.walk(in_dir)
        for f in files if os.path.splitext(f)[1] == ".py"
    )

    for fpath in pyfile_gen:
        with open(fpath, 'r') as f:
            src = f.read()

        # Parse the code and insert method call fixes.
        tree = cst.parse_module(src)
        updated = tree.visit(transformer)

        # Create the path and directory structure for the new file.
        updated_path = out_dir.joinpath(fpath.relative_to(in_dir))
        updated_path.parent.mkdir(parents=True, exist_ok=True)

        # Generate the updated source file at the corresponding path.
        with open(updated_path, 'w') as f:
            f.write(updated.code)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="""Fix up source that uses the bigtable client library.

The existing sources are NOT overwritten but are copied to output_dir with changes made.

Note: This tool operates at a best-effort level at converting positional
      parameters in client method calls to keyword based parameters.
      Cases where it WILL FAIL include
      A) * or ** expansion in a method call.
      B) Calls via function or method alias (includes free function calls)
      C) Indirect or dispatched calls (e.g. the method is looked up dynamically)

      These all constitute false negatives. The tool will also detect false
      positives when an API method shares a name with another method.
""")
    parser.add_argument(
        '-d',
        '--input-directory',
        required=True,
        dest='input_dir',
        help='the input directory to walk for python files to fix up',
    )
    parser.add_argument(
        '-o',
        '--output-directory',
        required=True,
        dest='output_dir',
        help='the directory to output files fixed via un-flattening',
    )
    args = parser.parse_args()
    input_dir = pathlib.Path(args.input_dir)
    output_dir = pathlib.Path(args.output_dir)
    if not input_dir.is_dir():
        print(
            f"input directory '{input_dir}' does not exist or is not a directory",
            file=sys.stderr,
        )
        sys.exit(-1)

    if not output_dir.is_dir():
        print(
            f"output directory '{output_dir}' does not exist or is not a directory",
            file=sys.stderr,
        )
        sys.exit(-1)

    if os.listdir(output_dir):
        print(
            f"output directory '{output_dir}' is not empty",
            file=sys.stderr,
        )
        sys.exit(-1)

    fix_files(input_dir, output_dir)


FILE END: ./.venv/bin/fixup_bigtable_v2_keywords.py



================================================================================
FILE START: ./app.py
================================================================================
import os
import asyncio
import uuid
from flask import Flask, render_template, request, jsonify, session
from dotenv import load_dotenv
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.genai import types

load_dotenv()

app = Flask(__name__)
app.secret_key = os.environ.get('SESSION_SECRET', 'dev-secret-key')

from agent.agent import root_agent

session_service = InMemorySessionService()

async def get_or_create_session_async(user_id: str):
    try:
        existing = await session_service.get_session(
            app_name="thay_tu_app",
            user_id=user_id,
            session_id=user_id
        )
        if existing:
            return existing
    except Exception:
        pass
    
    return await session_service.create_session(
        app_name="thay_tu_app",
        user_id=user_id,
        session_id=user_id
    )

async def run_agent_async(user_message: str, user_id: str):
    runner = Runner(
        agent=root_agent,
        app_name="thay_tu_app",
        session_service=session_service
    )
    
    adk_session = await get_or_create_session_async(user_id)
    
    content = types.Content(
        role="user",
        parts=[types.Part(text=user_message)]
    )
    
    response_text = ""
    async for event in runner.run_async(
        user_id=user_id,
        session_id=adk_session.id,
        new_message=content
    ):
        if hasattr(event, 'content') and event.content:
            for part in event.content.parts:
                if hasattr(part, 'text') and part.text:
                    response_text += part.text
    
    return response_text

def run_agent(user_message: str, user_id: str):
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        return loop.run_until_complete(run_agent_async(user_message, user_id))
    finally:
        loop.close()

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/ask', methods=['POST'])
def ask():
    try:
        data = request.get_json()
        user_message = data.get('message', '')
        
        if not user_message:
            return jsonify({'error': 'Vui l√≤ng nh·∫≠p c√¢u h·ªèi'}), 400
        
        user_id = session.get('user_id')
        if not user_id:
            user_id = str(uuid.uuid4())
            session['user_id'] = user_id
        
        response = run_agent(user_message, user_id)
        
        if not response:
            response = "Xin l·ªói, th·∫ßy ch∆∞a th·ªÉ tr·∫£ l·ªùi l√∫c n√†y. B·∫°n th·ª≠ h·ªèi l·∫°i nh√©!"
        
        return jsonify({'response': response})
    
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'C√≥ l·ªói x·∫£y ra: {str(e)}'}), 500

@app.route('/health')
def health():
    return jsonify({'status': 'healthy', 'agent': 'Th·∫ßy T∆∞'})

@app.route('/reset', methods=['POST'])
def reset_session():
    if 'user_id' in session:
        del session['user_id']
    return jsonify({'status': 'reset', 'message': 'Phi√™n ƒë√£ ƒë∆∞·ª£c l√†m m·ªõi'})

if __name__ == '__main__':
    debug_mode = os.environ.get('FLASK_DEBUG', 'false').lower() == 'true'
    print("üöÄ App ƒëang ch·∫°y t·∫°i: http://localhost:7860")
    app.run(host='0.0.0.0', port=7860, debug=debug_mode)


FILE END: ./app.py



================================================================================
FILE START: ./main.py
================================================================================
def main():
    print("Hello from repl-nix-workspace!")


if __name__ == "__main__":
    main()

# ======== Script run ===========

# python3 -m venv venv 
# source venv/bin/activate
# pip install -r requirements.txt
# python app.py

# docker-compose up --build -d  


FILE END: ./main.py



================================================================================
FILE START: ./attached_assets/agent_1765205934153.py
================================================================================
import re
import datetime
import random
from duckduckgo_search import DDGS
from google.adk.agents.llm_agent import Agent

# ==========================================
# 1. B·ªò X·ª¨ L√ù ƒê·∫¶U V√ÄO & LOGIC C∆† B·∫¢N (GI·ªÆ NGUY√äN)
# ==========================================

def _chuan_hoa_nam_sinh(text_input: str) -> int:
    text = str(text_input).lower().strip()
    match_4 = re.search(r'\b(19|20)\d{2}\b', text)
    if match_4: return int(match_4.group(0))
    match_2k = re.search(r'\b2k(\d{0,1})\b', text)
    if match_2k:
        suffix = match_2k.group(1)
        return 2000 if suffix == "" else 2000 + int(suffix)
    match_2 = re.search(r'\b\d{2}\b', text)
    if match_2:
        val = int(match_2.group(0))
        if 12 < val <= 99:
            return 1900 + val if val > 40 else 2000 + val
    return None

def _tinh_can_chi(nam_sinh: int) -> str:
    can = ["Canh", "T√¢n", "Nh√¢m", "Qu√Ω", "Gi√°p", "·∫§t", "B√≠nh", "ƒêinh", "M·∫≠u", "K·ª∑"]
    chi = ["Th√¢n", "D·∫≠u", "Tu·∫•t", "H·ª£i", "T√Ω", "S·ª≠u", "D·∫ßn", "M√£o", "Th√¨n", "T·ªµ", "Ng·ªç", "M√πi"]
    return f"{can[nam_sinh % 10]} {chi[nam_sinh % 12]}"

def _tinh_sao_han(nam_sinh: int, gioi_tinh: str) -> dict:
    current_year = datetime.datetime.now().year
    tuoi_mu = current_year - nam_sinh + 1
    # Logic b·∫£ng sao
    bang_sao_nam = {1: "La H·∫ßu", 2: "Th·ªï T√∫", 3: "Th·ªßy Di·ªáu", 4: "Th√°i B·∫°ch", 5: "Th√°i D∆∞∆°ng", 6: "V√¢n H·ªõn", 7: "K·∫ø ƒê√¥", 8: "Th√°i √Çm", 0: "M·ªôc ƒê·ª©c"}
    bang_sao_nu = {1: "K·∫ø ƒê√¥", 2: "V√¢n H·ªõn", 3: "M·ªôc ƒê·ª©c", 4: "Th√°i √Çm", 5: "Th·ªï T√∫", 6: "La H·∫ßu", 7: "Th√°i D∆∞∆°ng", 8: "Th√°i B·∫°ch", 0: "Th·ªßy Di·ªáu"}
    
    du_so = tuoi_mu % 9
    gioi_tinh = gioi_tinh.lower().strip()
    is_nu = any(x in gioi_tinh for x in ["n·ªØ", "g√°i", "c√¥", "b√†", "ch·ªã", "female"])
    
    sao = bang_sao_nu[du_so] if is_nu else bang_sao_nam[du_so]
    phai = "N·ªØ m·∫°ng" if is_nu else "Nam m·∫°ng"
        
    return {"tuoi_mu": tuoi_mu, "sao": sao, "phai": phai}

# ==========================================
# 2. TOOLS (TINH CH·ªàNH OUTPUT G·ªåN H∆†N)
# ==========================================

def xem_sao_giai_han(du_lieu_dau_vao: str, gioi_tinh: str = "nam") -> dict:
    ns = _chuan_hoa_nam_sinh(du_lieu_dau_vao)
    if ns is None: return {"status": "missing_info", "message": "Thi·∫øu nƒÉm sinh."}
    
    can_chi = _tinh_can_chi(ns)
    ket_qua = _tinh_sao_han(ns, gioi_tinh)
    
    return {
        "status": "success",
        "nam_sinh": ns,
        "can_chi": can_chi,
        "sao_han": f"Sao {ket_qua['sao']}",
        "loi_khuyen_goc": "D·ª±a v√†o sao n√†y ƒë·ªÉ ph√°n t·ªët x·∫•u."
    }

def tra_cuu_tu_vi_online(du_lieu_dau_vao: str, linh_vuc: str = "t·ªïng qu√°t") -> dict:
    ns = _chuan_hoa_nam_sinh(du_lieu_dau_vao)
    if ns is None: return {"status": "missing_info", "message": "Thi·∫øu nƒÉm sinh."}
        
    try:
        can_chi = _tinh_can_chi(ns)
        current_year = datetime.datetime.now().year + 1
        
        # Query t·∫≠p trung v√†o "lu·∫≠n gi·∫£i" ƒë·ªÉ l·∫•y n·ªôi dung ch·∫•t l∆∞·ª£ng
        query = f"T·ª≠ vi tu·ªïi {can_chi} sinh nƒÉm {ns} nƒÉm {current_year} {linh_vuc} lu·∫≠n gi·∫£i chi ti·∫øt"
        print(f"\n[SYSTEM] üîç Tra c·ª©u: '{query}'")

        results = DDGS().text(keywords=query, region='vn-vi', max_results=4)
        
        knowledge = []
        if results:
            for res in results:
                # L·ªçc r√°c
                if len(res['body']) > 60 and "ƒëƒÉng nh·∫≠p" not in res['body'].lower() and "yahoo" not in res['body'].lower():
                    knowledge.append(f"- {res['body']}")
        
        if not knowledge:
            return {"status": "no_data", "message": "Kh√¥ng t√¨m th·∫•y online, h√£y d√πng ki·∫øn th·ª©c Can Chi ng≈© h√†nh t·ª± suy lu·∫≠n."}

        return {
            "status": "success",
            "tuoi": can_chi,
            "du_lieu_tu_vi": "\n".join(knowledge),
            "instruction": "Ph√¢n t√≠ch d·ªØ li·ªáu n√†y. N·∫øu t·ªët -> Vui v·∫ª. N·∫øu x·∫•u -> Nghi√™m t√∫c, an ·ªßi."
        }

    except Exception as e:
        return {"status": "error", "message": f"L·ªói: {e}"}

# ==========================================
# 3. PERSONA: TH·∫¶Y T∆Ø "S√ÇU S·∫ÆC" (NO ACTIONS)
# ==========================================

root_agent = Agent(
    model='gemini-2.5-flash',
    name='thay_tu_refined',
    description="Th·∫ßy T∆∞ tinh t·∫ø, ·ª©ng bi·∫øn linh ho·∫°t.",
    instruction=(
        "Con l√† 'Th·∫ßy T∆∞' - chuy√™n gia t·ª≠ vi Nam B·ªô hi·ªán ƒë·∫°i."
        "\n\n"
        "1. QUY T·∫ÆC B·∫§T DI B·∫§T D·ªäCH:"
        "- **KH√îNG** d√πng h√†nh ƒë·ªông trong ngo·∫∑c ƒë∆°n nh∆∞ (c∆∞·ªùi), (v·ªó ƒë√πi). Ch·ªâ d√πng l·ªùi n√≥i t·ª± nhi√™n."
        "- **KH√îNG** v√≤ng vo. Tr·∫£ l·ªùi th·∫≥ng v√†o tr·ªçng t√¢m c√¢u h·ªèi ngay."
        "- **KH√îNG** ƒë·ªï l·ªói cho 'c√¥ng c·ª•' hay 'Zalo nhi·ªÖu s√≥ng'. N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu online, h√£y d√πng ki·∫øn th·ª©c Ng≈© H√†nh (Kim M·ªôc Th·ªßy H·ªèa Th·ªï) ƒë·ªÉ t·ª± lu·∫≠n gi·∫£i."
        "\n\n"
        "2. C∆† CH·∫æ C·∫¢M X√öC (ADAPTIVE TONE):"
        "- **Tr∆∞·ªùng h·ª£p VUI (H·ªèi ch∆°i, tin t·ªët, ƒëang y√™u):** D√πng gi·ªçng ƒëi·ªáu Gen Z, h√†i h∆∞·ªõc, d√πng t·ª´: 'Ch·ªët ƒë∆°n', 'X·ªãn s√≤', 'Ngon l√†nh', 'Green flag'."
        "- **Tr∆∞·ªùng h·ª£p NGHI√äM T√öC (Tin x·∫•u, sao h·∫°n n·∫∑ng, th·∫•t t√¨nh):** B·ªè ngay gi·ªçng c·ª£t nh·∫£. D√πng gi·ªçng tr·∫ßm ·ªïn, ch√¢n th√†nh, ƒë∆∞a l·ªùi khuy√™n th·ª±c t·∫ø (Healing, c·∫©n th·∫≠n xe c·ªô, gi·ªØ ti·ªÅn)."
        "\n\n"
        "3. C·∫§U TR√öC TR·∫¢ L·ªúI:"
        "- **M·ªü ƒë·∫ßu:** G·ªçi t√™n Can Chi kh√°ch (VD: T√¢n T·ªµ 2001) ƒë·ªÉ x√°c nh·∫≠n."
        "- **Th√¢n b√†i (Ng·∫Øn g·ªçn):** ƒê∆∞a ra nh·∫≠n ƒë·ªãnh T·ªët/X·∫•u ngay. T√≥m t·∫Øt 1-2 √Ω ch√≠nh quan tr·ªçng nh·∫•t."
        "- **K·∫øt b√†i:** H·ªèi xem kh√°ch c√≥ mu·ªën ƒë√†o s√¢u v√†o chi ti·∫øt kh√¥ng."
    ),
    tools=[xem_sao_giai_han, tra_cuu_tu_vi_online], 
    # database: conversation tools
    # system prompt (cache): 4. ng∆∞·ªùi ƒë√≥ vui => genZ, ng∆∞·ªùi ƒë√≥ nghi√™m t√∫c => nghi√™m t√∫c,... 5. t√≠ch h·ª£p API s·∫£n ph·∫©m (b√°n s√°ch, focus problem?)
)

if __name__ == "__main__":
    print("--- TH·∫¶Y T∆Ø (PHI√äN B·∫¢N TINH CH·ªàNH) ---")

FILE END: ./attached_assets/agent_1765205934153.py



================================================================================
FILE START: ./demo-code-agent/agent_demo.py
================================================================================
from google.adk.agents.llm_agent import Agent
from datetime import datetime
from zoneinfo import ZoneInfo # Th∆∞ vi·ªán x·ª≠ l√Ω m√∫i gi·ªù c√≥ s·∫µn trong Python 3.9+

# --- PH·∫¶N 1: ƒê·ªäNH NGHƒ®A TOOLS (C√îNG C·ª§) ---

def get_current_time(timezone: str) -> dict:
    """
    Tr·∫£ v·ªÅ th·ªùi gian hi·ªán t·∫°i ch√≠nh x√°c theo m√∫i gi·ªù ƒë∆∞·ª£c y√™u c·∫ßu.
    
    Args:
        timezone (str): T√™n m√∫i gi·ªù (v√≠ d·ª•: 'Asia/Ho_Chi_Minh', 'America/New_York', 'Europe/London').
    """
    try:
        # L·∫•y gi·ªù th·ª±c t·∫ø t·ª´ h·ªá th·ªëng
        now = datetime.now(ZoneInfo(timezone))
        return {
            "status": "success",
            "timezone": timezone,
            "time": now.strftime("%H:%M:%S"), # Gi·ªù:Ph√∫t:Gi√¢y
            "date": now.strftime("%Y-%m-%d"), # NƒÉm-Th√°ng-Ng√†y
            "day_of_week": now.strftime("%A") # Th·ª© trong tu·∫ßn
        }
    except Exception as e:
        # X·ª≠ l√Ω n·∫øu AI g·ª≠i sai t√™n m√∫i gi·ªù
        return {
            "status": "error", 
            "message": f"Kh√¥ng t√¨m th·∫•y m√∫i gi·ªù '{timezone}'. Vui l√≤ng th·ª≠ l·∫°i v·ªõi t√™n chu·∫©n (VD: Asia/Tokyo)."
        }

# --- PH·∫¶N 2: ƒê·ªäNH NGHƒ®A AGENT ---

root_agent = Agent(
    model='gemini-2.5-flash',
    name='root_agent',
    description="Tr·ª£ l√Ω th·ªùi gian qu·ªëc t·∫ø.",
    instruction=(
        "B·∫°n l√† m·ªôt tr·ª£ l√Ω h·ªØu √≠ch chuy√™n v·ªÅ th·ªùi gian. "
        "Khi ng∆∞·ªùi d√πng h·ªèi gi·ªù t·∫°i m·ªôt th√†nh ph·ªë, h√£y suy lu·∫≠n ra 'timezone' c·ªßa th√†nh ph·ªë ƒë√≥ "
        "v√† s·ª≠ d·ª•ng tool 'get_current_time' ƒë·ªÉ l·∫•y th√¥ng tin ch√≠nh x√°c. "
        "Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát th√¢n thi·ªán."
    ),
    # ƒêƒÉng k√Ω tool v√†o agent t·∫°i ƒë√¢y
    tools=[get_current_time],
)

# D√≤ng n√†y ƒë·ªÉ x√°c nh·∫≠n code kh√¥ng l·ªói c√∫ ph√°p khi ch·∫°y
if __name__ == "__main__":
    print("Agent 'root_agent' ƒë√£ s·∫µn s√†ng v·ªõi tool 'get_current_time'.")

FILE END: ./demo-code-agent/agent_demo.py



================================================================================
FILE START: ./demo-code-agent/__init__.py
================================================================================
from . import agent


FILE END: ./demo-code-agent/__init__.py



================================================================================
FILE START: ./demo-code-agent/agent.py
================================================================================
import re
import datetime
import random
from duckduckgo_search import DDGS
from google.adk.agents.llm_agent import Agent

# ==========================================
# 1. B·ªò X·ª¨ L√ù ƒê·∫¶U V√ÄO & LOGIC C∆† B·∫¢N (GI·ªÆ NGUY√äN)
# ==========================================

def _chuan_hoa_nam_sinh(text_input: str) -> int:
    text = str(text_input).lower().strip()
    match_4 = re.search(r'\b(19|20)\d{2}\b', text)
    if match_4: return int(match_4.group(0))
    match_2k = re.search(r'\b2k(\d{0,1})\b', text)
    if match_2k:
        suffix = match_2k.group(1)
        return 2000 if suffix == "" else 2000 + int(suffix)
    match_2 = re.search(r'\b\d{2}\b', text)
    if match_2:
        val = int(match_2.group(0))
        if 12 < val <= 99:
            return 1900 + val if val > 40 else 2000 + val
    return None

def _tinh_can_chi(nam_sinh: int) -> str:
    can = ["Canh", "T√¢n", "Nh√¢m", "Qu√Ω", "Gi√°p", "·∫§t", "B√≠nh", "ƒêinh", "M·∫≠u", "K·ª∑"]
    chi = ["Th√¢n", "D·∫≠u", "Tu·∫•t", "H·ª£i", "T√Ω", "S·ª≠u", "D·∫ßn", "M√£o", "Th√¨n", "T·ªµ", "Ng·ªç", "M√πi"]
    return f"{can[nam_sinh % 10]} {chi[nam_sinh % 12]}"

def _tinh_sao_han(nam_sinh: int, gioi_tinh: str) -> dict:
    current_year = datetime.datetime.now().year
    tuoi_mu = current_year - nam_sinh + 1
    # Logic b·∫£ng sao
    bang_sao_nam = {1: "La H·∫ßu", 2: "Th·ªï T√∫", 3: "Th·ªßy Di·ªáu", 4: "Th√°i B·∫°ch", 5: "Th√°i D∆∞∆°ng", 6: "V√¢n H·ªõn", 7: "K·∫ø ƒê√¥", 8: "Th√°i √Çm", 0: "M·ªôc ƒê·ª©c"}
    bang_sao_nu = {1: "K·∫ø ƒê√¥", 2: "V√¢n H·ªõn", 3: "M·ªôc ƒê·ª©c", 4: "Th√°i √Çm", 5: "Th·ªï T√∫", 6: "La H·∫ßu", 7: "Th√°i D∆∞∆°ng", 8: "Th√°i B·∫°ch", 0: "Th·ªßy Di·ªáu"}
    
    du_so = tuoi_mu % 9
    gioi_tinh = gioi_tinh.lower().strip()
    is_nu = any(x in gioi_tinh for x in ["n·ªØ", "g√°i", "c√¥", "b√†", "ch·ªã", "female"])
    
    sao = bang_sao_nu[du_so] if is_nu else bang_sao_nam[du_so]
    phai = "N·ªØ m·∫°ng" if is_nu else "Nam m·∫°ng"
        
    return {"tuoi_mu": tuoi_mu, "sao": sao, "phai": phai}

# ==========================================
# 2. TOOLS (TINH CH·ªàNH OUTPUT G·ªåN H∆†N)
# ==========================================

def xem_sao_giai_han(du_lieu_dau_vao: str, gioi_tinh: str = "nam") -> dict:
    ns = _chuan_hoa_nam_sinh(du_lieu_dau_vao)
    if ns is None: return {"status": "missing_info", "message": "Thi·∫øu nƒÉm sinh."}
    
    can_chi = _tinh_can_chi(ns)
    ket_qua = _tinh_sao_han(ns, gioi_tinh)
    
    return {
        "status": "success",
        "nam_sinh": ns,
        "can_chi": can_chi,
        "sao_han": f"Sao {ket_qua['sao']}",
        "loi_khuyen_goc": "D·ª±a v√†o sao n√†y ƒë·ªÉ ph√°n t·ªët x·∫•u."
    }

def tra_cuu_tu_vi_online(du_lieu_dau_vao: str, linh_vuc: str = "t·ªïng qu√°t") -> dict:
    ns = _chuan_hoa_nam_sinh(du_lieu_dau_vao)
    if ns is None: return {"status": "missing_info", "message": "Thi·∫øu nƒÉm sinh."}
        
    try:
        can_chi = _tinh_can_chi(ns)
        current_year = datetime.datetime.now().year + 1
        
        # Query t·∫≠p trung v√†o "lu·∫≠n gi·∫£i" ƒë·ªÉ l·∫•y n·ªôi dung ch·∫•t l∆∞·ª£ng
        query = f"T·ª≠ vi tu·ªïi {can_chi} sinh nƒÉm {ns} nƒÉm {current_year} {linh_vuc} lu·∫≠n gi·∫£i chi ti·∫øt"
        print(f"\n[SYSTEM] üîç Tra c·ª©u: '{query}'")

        results = DDGS().text(keywords=query, region='vn-vi', max_results=4)
        
        knowledge = []
        if results:
            for res in results:
                # L·ªçc r√°c
                if len(res['body']) > 60 and "ƒëƒÉng nh·∫≠p" not in res['body'].lower() and "yahoo" not in res['body'].lower():
                    knowledge.append(f"- {res['body']}")
        
        if not knowledge:
            return {"status": "no_data", "message": "Kh√¥ng t√¨m th·∫•y online, h√£y d√πng ki·∫øn th·ª©c Can Chi ng≈© h√†nh t·ª± suy lu·∫≠n."}

        return {
            "status": "success",
            "tuoi": can_chi,
            "du_lieu_tu_vi": "\n".join(knowledge),
            "instruction": "Ph√¢n t√≠ch d·ªØ li·ªáu n√†y. N·∫øu t·ªët -> Vui v·∫ª. N·∫øu x·∫•u -> Nghi√™m t√∫c, an ·ªßi."
        }

    except Exception as e:
        return {"status": "error", "message": f"L·ªói: {e}"}

# ==========================================
# 3. PERSONA: TH·∫¶Y T∆Ø "S√ÇU S·∫ÆC" (NO ACTIONS)
# ==========================================

root_agent = Agent(
    model='gemini-2.5-flash',
    name='thay_tu_refined',
    description="Th·∫ßy T∆∞ tinh t·∫ø, ·ª©ng bi·∫øn linh ho·∫°t.",
    instruction=(
        "Con l√† 'Th·∫ßy T∆∞' - chuy√™n gia t·ª≠ vi Nam B·ªô hi·ªán ƒë·∫°i."
        "\n\n"
        "1. QUY T·∫ÆC B·∫§T DI B·∫§T D·ªäCH:"
        "- **KH√îNG** d√πng h√†nh ƒë·ªông trong ngo·∫∑c ƒë∆°n nh∆∞ (c∆∞·ªùi), (v·ªó ƒë√πi). Ch·ªâ d√πng l·ªùi n√≥i t·ª± nhi√™n."
        "- **KH√îNG** v√≤ng vo. Tr·∫£ l·ªùi th·∫≥ng v√†o tr·ªçng t√¢m c√¢u h·ªèi ngay."
        "- **KH√îNG** ƒë·ªï l·ªói cho 'c√¥ng c·ª•' hay 'Zalo nhi·ªÖu s√≥ng'. N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu online, h√£y d√πng ki·∫øn th·ª©c Ng≈© H√†nh (Kim M·ªôc Th·ªßy H·ªèa Th·ªï) ƒë·ªÉ t·ª± lu·∫≠n gi·∫£i."
        "\n\n"
        "2. C∆† CH·∫æ C·∫¢M X√öC (ADAPTIVE TONE):"
        "- **Tr∆∞·ªùng h·ª£p VUI (H·ªèi ch∆°i, tin t·ªët, ƒëang y√™u):** D√πng gi·ªçng ƒëi·ªáu Gen Z, h√†i h∆∞·ªõc, d√πng t·ª´: 'Ch·ªët ƒë∆°n', 'X·ªãn s√≤', 'Ngon l√†nh', 'Green flag'."
        "- **Tr∆∞·ªùng h·ª£p NGHI√äM T√öC (Tin x·∫•u, sao h·∫°n n·∫∑ng, th·∫•t t√¨nh):** B·ªè ngay gi·ªçng c·ª£t nh·∫£. D√πng gi·ªçng tr·∫ßm ·ªïn, ch√¢n th√†nh, ƒë∆∞a l·ªùi khuy√™n th·ª±c t·∫ø (Healing, c·∫©n th·∫≠n xe c·ªô, gi·ªØ ti·ªÅn)."
        "\n\n"
        "3. C·∫§U TR√öC TR·∫¢ L·ªúI:"
        "- **M·ªü ƒë·∫ßu:** G·ªçi t√™n Can Chi kh√°ch (VD: T√¢n T·ªµ 2001) ƒë·ªÉ x√°c nh·∫≠n."
        "- **Th√¢n b√†i (Ng·∫Øn g·ªçn):** ƒê∆∞a ra nh·∫≠n ƒë·ªãnh T·ªët/X·∫•u ngay. T√≥m t·∫Øt 1-2 √Ω ch√≠nh quan tr·ªçng nh·∫•t."
        "- **K·∫øt b√†i:** H·ªèi xem kh√°ch c√≥ mu·ªën ƒë√†o s√¢u v√†o chi ti·∫øt kh√¥ng."
    ),
    tools=[xem_sao_giai_han, tra_cuu_tu_vi_online], 
    # database: conversation tools
    # system prompt (cache): 4. ng∆∞·ªùi ƒë√≥ vui => genZ, ng∆∞·ªùi ƒë√≥ nghi√™m t√∫c => nghi√™m t√∫c,... 5. t√≠ch h·ª£p API s·∫£n ph·∫©m (b√°n s√°ch, focus problem?)
)

if __name__ == "__main__":
    print("--- TH·∫¶Y T∆Ø (PHI√äN B·∫¢N TINH CH·ªàNH) ---")

FILE END: ./demo-code-agent/agent.py



